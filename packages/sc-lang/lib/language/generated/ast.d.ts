/******************************************************************************
 * This file was generated by langium-cli 3.3.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/
import type { AstNode, Reference, ReferenceInfo, TypeMetaData } from 'langium';
import { AbstractAstReflection } from 'langium';
export declare const ScTerminals: {
    WS: RegExp;
    ID: RegExp;
    NUMBER: RegExp;
    STRING: RegExp;
    ML_COMMENT: RegExp;
    SL_COMMENT: RegExp;
};
export type ScTerminalNames = keyof typeof ScTerminals;
export type ScKeywordNames = "!" | "!=" | "(" | ")" | "*" | "+" | "," | "-" | "/" | ";" | "<" | "<=" | "=" | "==" | ">" | ">=" | "and" | "char" | "else" | "for" | "if" | "int" | "or" | "return" | "while" | "{" | "}";
export type ScTokenNames = ScTerminalNames | ScKeywordNames;
export type Definition = FunctionDeclaration | NamedElement;
export declare const Definition = "Definition";
export declare function isDefinition(item: unknown): item is Definition;
export type Expression = BinaryExpression | CharExpression | MemberCall | NumberExpression | UnaryExpression;
export declare const Expression = "Expression";
export declare function isExpression(item: unknown): item is Expression;
export type NamedElement = FunctionDeclaration | Parameter | VariableDeclaration;
export declare const NamedElement = "NamedElement";
export declare function isNamedElement(item: unknown): item is NamedElement;
export type Statement = AssignmentStatement | Expression | ForStatement | IfStatement | NamedElement | ReturnStatement | WhileStatement;
export declare const Statement = "Statement";
export declare function isStatement(item: unknown): item is Statement;
export interface AssignmentStatement extends AstNode {
    readonly $container: Block | ForStatement;
    readonly $type: 'AssignmentStatement';
    value: Expression;
    varRef: Reference<VariableDeclaration>;
}
export declare const AssignmentStatement = "AssignmentStatement";
export declare function isAssignmentStatement(item: unknown): item is AssignmentStatement;
export interface BinaryExpression extends AstNode {
    readonly $container: AssignmentStatement | BinaryExpression | Block | ForStatement | IfStatement | MemberCall | ReturnStatement | UnaryExpression | VariableDeclaration | WhileStatement;
    readonly $type: 'BinaryExpression';
    left: Expression;
    operator: '!=' | '*' | '+' | '-' | '/' | '<' | '<=' | '==' | '>' | '>=' | 'and' | 'or';
    right: Expression;
}
export declare const BinaryExpression = "BinaryExpression";
export declare function isBinaryExpression(item: unknown): item is BinaryExpression;
export interface Block extends AstNode {
    readonly $container: ForStatement | FunctionDeclaration | IfStatement | WhileStatement;
    readonly $type: 'Block';
    statements: Array<Statement>;
}
export declare const Block = "Block";
export declare function isBlock(item: unknown): item is Block;
export interface CharExpression extends AstNode {
    readonly $container: AssignmentStatement | BinaryExpression | Block | ForStatement | IfStatement | MemberCall | ReturnStatement | UnaryExpression | VariableDeclaration | WhileStatement;
    readonly $type: 'CharExpression';
    value: string;
}
export declare const CharExpression = "CharExpression";
export declare function isCharExpression(item: unknown): item is CharExpression;
export interface ForStatement extends AstNode {
    readonly $container: Block;
    readonly $type: 'ForStatement';
    block: Block;
    condition?: Expression;
    counter?: NamedElement;
    execution?: AssignmentStatement;
}
export declare const ForStatement = "ForStatement";
export declare function isForStatement(item: unknown): item is ForStatement;
export interface FunctionDeclaration extends AstNode {
    readonly $container: Block | ForStatement | Program;
    readonly $type: 'FunctionDeclaration';
    body: Block;
    name: string;
    parameters: Array<Parameter>;
    returnType: boolean;
}
export declare const FunctionDeclaration = "FunctionDeclaration";
export declare function isFunctionDeclaration(item: unknown): item is FunctionDeclaration;
export interface IfStatement extends AstNode {
    readonly $container: Block;
    readonly $type: 'IfStatement';
    block: Block;
    condition: Expression;
    elseBlock?: Block;
}
export declare const IfStatement = "IfStatement";
export declare function isIfStatement(item: unknown): item is IfStatement;
export interface MemberCall extends AstNode {
    readonly $container: AssignmentStatement | BinaryExpression | Block | ForStatement | IfStatement | MemberCall | ReturnStatement | UnaryExpression | VariableDeclaration | WhileStatement;
    readonly $type: 'MemberCall';
    arguments: Array<Expression>;
    element: Reference<NamedElement>;
    explicitOperationCall: boolean;
}
export declare const MemberCall = "MemberCall";
export declare function isMemberCall(item: unknown): item is MemberCall;
export interface NumberExpression extends AstNode {
    readonly $container: AssignmentStatement | BinaryExpression | Block | ForStatement | IfStatement | MemberCall | ReturnStatement | UnaryExpression | VariableDeclaration | WhileStatement;
    readonly $type: 'NumberExpression';
    value: number;
}
export declare const NumberExpression = "NumberExpression";
export declare function isNumberExpression(item: unknown): item is NumberExpression;
export interface Parameter extends AstNode {
    readonly $container: Block | ForStatement | FunctionDeclaration | Program;
    readonly $type: 'Parameter';
    name: string;
    type: TypeReference;
}
export declare const Parameter = "Parameter";
export declare function isParameter(item: unknown): item is Parameter;
export interface Program extends AstNode {
    readonly $type: 'Program';
    definitions: Array<Definition>;
}
export declare const Program = "Program";
export declare function isProgram(item: unknown): item is Program;
export interface ReturnStatement extends AstNode {
    readonly $container: Block;
    readonly $type: 'ReturnStatement';
    value?: Expression;
}
export declare const ReturnStatement = "ReturnStatement";
export declare function isReturnStatement(item: unknown): item is ReturnStatement;
export interface TypeReference extends AstNode {
    readonly $container: Parameter | VariableDeclaration;
    readonly $type: 'TypeReference';
    primitive: 'char' | 'int';
}
export declare const TypeReference = "TypeReference";
export declare function isTypeReference(item: unknown): item is TypeReference;
export interface UnaryExpression extends AstNode {
    readonly $container: AssignmentStatement | BinaryExpression | Block | ForStatement | IfStatement | MemberCall | ReturnStatement | UnaryExpression | VariableDeclaration | WhileStatement;
    readonly $type: 'UnaryExpression';
    operator: '!' | '-';
    value: Expression;
}
export declare const UnaryExpression = "UnaryExpression";
export declare function isUnaryExpression(item: unknown): item is UnaryExpression;
export interface VariableDeclaration extends AstNode {
    readonly $container: Block | ForStatement | Program;
    readonly $type: 'VariableDeclaration';
    assignment: boolean;
    name: string;
    type: TypeReference;
    value?: Expression;
}
export declare const VariableDeclaration = "VariableDeclaration";
export declare function isVariableDeclaration(item: unknown): item is VariableDeclaration;
export interface WhileStatement extends AstNode {
    readonly $container: Block;
    readonly $type: 'WhileStatement';
    block: Block;
    condition: Expression;
}
export declare const WhileStatement = "WhileStatement";
export declare function isWhileStatement(item: unknown): item is WhileStatement;
export type ScAstType = {
    AssignmentStatement: AssignmentStatement;
    BinaryExpression: BinaryExpression;
    Block: Block;
    CharExpression: CharExpression;
    Definition: Definition;
    Expression: Expression;
    ForStatement: ForStatement;
    FunctionDeclaration: FunctionDeclaration;
    IfStatement: IfStatement;
    MemberCall: MemberCall;
    NamedElement: NamedElement;
    NumberExpression: NumberExpression;
    Parameter: Parameter;
    Program: Program;
    ReturnStatement: ReturnStatement;
    Statement: Statement;
    TypeReference: TypeReference;
    UnaryExpression: UnaryExpression;
    VariableDeclaration: VariableDeclaration;
    WhileStatement: WhileStatement;
};
export declare class ScAstReflection extends AbstractAstReflection {
    getAllTypes(): string[];
    protected computeIsSubtype(subtype: string, supertype: string): boolean;
    getReferenceType(refInfo: ReferenceInfo): string;
    getTypeMetaData(type: string): TypeMetaData;
}
export declare const reflection: ScAstReflection;
